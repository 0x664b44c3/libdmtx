.\" $Id$
.\"
.\" Man page for the libdmtx project.
.\"
.\" To view: $ groff -man -T ascii libdmtx.3 | less
.\" To text: $ groff -man -T ascii libdmtx.3 | col -b | expand
.\"
.TH LIBDMTX 3 "April X, 2008"
.SH NAME
libdmtx \- Data Matrix Encoder/Decoder Library 0.5.0
.SH SYNOPSIS
\fB#include <dmtx.h>\fP

\fIENCODING FUNCTIONS\fP

\fBDmtxEncode dmtxEncodeStructInit(\fIvoid\fP);\fP

\fBint dmtxEncodeDataMatrix(DmtxEncode *\fIenc\fP, int \fIn\fP, unsigned char *\fIs\fP, int \fIsizeIdxRequest\fP);\fP

\fBint dmtxEncodeDataMosaic(DmtxEncode *\fIenc\fP, int \fIn\fP, unsigned char *\fIs\fP, int \fIsizeIdxRequest\fP);\fP

\fBvoid dmtxEncodeStructDeInit(DmtxEncode *\fIenc\fP);\fP

\fIDECODING FUNCTIONS\fP

\fBDmtxDecode dmtxDecodeStructInit(DmtxImage *\fIimg\fP, DmtxPixelLoc \fIp0\fP, DmtxPixelLoc \fIp1\fP, int \fIgap\fP);\fP

\fBDmtxRegion dmtxDecodeFindNextRegion(DmtxDecode *\fIdec\fP);\fP

\fBDmtxMessage *dmtxDecodeMatrixRegion(DmtxDecode *\fIdec\fP, DmtxRegion *\fIreg\fP);\fP

\fBDmtxMessage *dmtxDecodeMosaicRegion(DmtxDecode *\fIdec\fP, DmtxRegion *\fIreg\fP);\fP

\fBvoid dmtxDecodeStructDeInit(DmtxDecode *\fIdec\fP);\fP

\fICOMMON FUNCTIONS\fP

\fBDmtxMessage *dmtxMessageMalloc(int \fIsizeIdx\fP);\fP

\fBvoid dmtxMessageFree(DmtxMessage **\fImesg\fP);\fP

\fBDmtxImage *dmtxImageMalloc(int \fIwidth\fP, int \fIheight\fP);\fP

\fBint dmtxImageFree(DmtxImage **\fIimg\fP);\fP

.SH DESCRIPTION
\fIlibdmtx\fP is a shared library that provides the ability to read and write ECC200 Data Matrix barcodes.  The accompanying utility programs \fIdmtxread\fP and \fIdmtxwrite\fP enable libdmtx functionality from the command line, and also provide a good reference for programmers who wish to write their own programs that interact with libdmtx.  Refer to the man pages on dmtxread(1) and dmtxwrite(1) for details on their syntax and options.

Data Matrix barcodes are two-dimensional patterns resembling a checkerboard in appearance that hold a high density of data with built-in error correction.  The Data Matrix symbology was invented and released into the public domain by RVSI Acuity CiMatrix.

.SH ENCODING - Generating Data Matrix Barcodes
\fIlibdmtx\fP provides a simple set of functions for encoding Data Matrix barcodes.  The following steps will produce an image that encodes the specified message in a valid barcode symbol.

1. Call \fBdmtxEncodeStructInit()\fP

This function initializes the internal values of the encoding process, and must be called before any other encoding functions.

2. Call either \fBdmtxEncodeDataMatrix()\fP or \fBdmtxEncodeDataMosaic()\fP

These functions (depending on the desired barcode format) create one barcode per call, and write the resulting image to an internal structure in the DmtxEncode variable.  The calling program is responsible for creating an image file from this data.

3. Call \fBdmtxEncodeStructDeInit()\fP

This function resets the internal encoding values and frees the image and message memory allocated during the encoding process.

.SH DECODING - Reading Data Matrix Barcodes
\fIlibdmtx\fP provides small number of default decoding functions, and provides additional flexibility through parameters and callback functions.

1. Call \fBdmtxDecodeStructCreate()\fP

Creates the \fIlibdmtx\fP information struct.  This struct contains user decoding information and runtime options.  \fBdmtxDecodeStructCreate()\fP must be called before any other scanning functions.

2. Call \fBdmtxImageInit()\fP

Initializes an image structure for the calling program to use.  \fIlibdmtx\fP provides its own image structure that must be populated with the raw image information by the calling program before beginning the scan.  An initialized and populated image is required for any scanning activities.

3. Call \fBdmtxScanStartNew()\fP

Resets the counters and lists before a new scan begins.  This is necessary because libdmtx might find multiple Data Matrix barcodes in an image, and therefore maintains a list of barcode regions.  This function clears the lists between reads so the program doesn't exhaust the system memory with already-scanned barcode regions.

4. Call \fBdmtxScanLine()\fP

Performs the actual scan of a row or column (1 pixel wide) from the source image.  It returns number of Data Matrix barcodes that were found, and stores the barcode information in a list from the decode struct.  Multiple calls to \fBdmtxScanLine()\fP can happen between \fBdmtxScanStartNew()\fP (for example, to make the familiar "cross pattern" like in the supermarket checkout lane).

5. Call \fBdmtxDecodeGetMatrixCount()\fP

Returns the number of Data Matrix barcodes that are currently stored in the DmtxDecode list.  If none were found, will return 0.

6. Call \fBdmtxDecodeGetMatrix()\fP

Returns a pointer to the DmtxRegion struct held by DmtxDecode.  Data Matrix information (geometries, encoded and decoded data) will be stored until next call to \fBdmtxScanStartNew()\fP or \fBdmtxDecodeStructDestroy()\fP.

7. Call \fBdmtxImageDeInit()\fP

Resets and frees memory associated with DmtxImage struct.  This is the complement to \fBdmtxImageInit()\fP.

8. Call \fBdmtxDecodeStructDestroy()\fP

Resets and frees memory associated with DmtxDecode struct.  This is the complement to \fBdmtxDecodeInit()\fP.

.SH EXAMPLE PROGRAM

This program demonstrates both directions of \fIlibdmtx\fP functionality by first creating a Data Matrix barcode with its encoding functionality and then reading it back with the decoding functionality.  If everything works correctly then the original input data should match the final output data.

  #include <stdlib.h>
  #include <stdio.h>
  #include <string.h>
  #include <unistd.h>
  #include <dmtx.h>

  int
  main(int argc, char **argv)
  {
     int count = 0;
     unsigned char testString[] = "30Q324343430794<OQQ";
     DmtxImage image;
     DmtxEncode *encode;
     DmtxDecode *decode;

     fprintf(stdout, "input:  \\"%s\\"\\n", testString);

     /*
      * 1) Write a new Data Matrix barcode (in memory)
      */

     encode = dmtxEncodeCreate();
     dmtxEncodeDataMatrix(encode, strlen((char *)testString),
           testString, DMTX_SYMBOL_SQUARE_AUTO);

     // Take copy of new image before freeing DmtxEncode struct
     image = encode->image;
     image.pxl = (DmtxPixel *)malloc(image.width * image.height *
           sizeof(DmtxPixel));
     if(image.pxl == NULL) {
        perror("Malloc error");
        exit(1);
     }
     memcpy(image.pxl, encode->image.pxl, image.width *
           image.height * sizeof(DmtxPixel));
     dmtxEncodeDestroy(&encode);

     /*
      * 2) Read the Data Matrix barcode from above
      */

     decode = dmtxDecodeStructCreate();
     decode->option = DmtxSingleScanOnly;
     decode->image = image;

     count += dmtxScanLine(decode, DmtxDirUp,
           decode->image.width/2);

     count += dmtxScanLine(decode, DmtxDirRight,
           decode->image.height/2);

     if(count > 0) {
        fprintf(stdout, "output: \\"");
        fwrite(decode->matrix[0].output, sizeof(unsigned char),
              decode->matrix[0].outputIdx, stdout);
        fprintf(stdout, "\\"\\n\\n");
     }

     dmtxDecodeStructDestroy(&decode);

     exit(0);
  }

.SH "SEE ALSO"
\fIdmtxread\fP(1), \fIdmtxwrite\fP(1)
.SH STANDARDS
ISO/IEC 16022:2000
.PP
ANSI/AIM BC11 ISS
.SH BUGS
Email bug reports to mike@dragonflylogic.com
.SH AUTHOR
Copyright (c) 2008 Mike Laughton
.\" end of man page
