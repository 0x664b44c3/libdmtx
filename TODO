TODO Items
-----------------------------------------------------------------

IMMEDIATE
   x switch to incremental (one matrix) approach, which passes back buffer no matter what
      x Remove dmtxScanStartNew()
      x Remove dmtxDecodeGetMatrixCount()
      x Remove dmtxDecodeGetMatrix()
      x Add status

   x write buffer dumping function in dmtxread (takes into account b&w or rgb barcode dumps)

   / finsh writing and integrate 4-direction weighted module reads (see notes at bottom)

   o pass decision back to calling program whether to scan (requiring malloc) it
   o change dmtxFindNextRegion() to return region (not malloc'd)
   o update gltest to use the new calling structure

   / rename DmtxMatrixRegion to DmtxRegion
   o split out actual data fields
   o remove mosaic field from DmtxDecode (and replace functionality by calling dedicated named function)
   o remove DmtxRegion from decode and pass it between functions explicitly

   o write fully structured debug barcode dump from dmtxread (currently just mapping grid)
   o add data to the malloc'd image buffer (for writing log data and tracking progress)
   o improve black/white decision process
   o consider changing rounding of zero crossing math to nearest center between pixels

version 0.5:
  x libdmtx:   Remove "2" from functions named *MatrixRegion2*() (whoops)
  x libdmtx:   Fix TestForEndOfSymbolEdifact() to handle special cases correctly
  / libdmtx:   Use new Edifact decode function that doesn't assume full triplet
  / libdmtx:   Thorough test for memory leaks
  / libdmtx:   Implement multiple barcodes as incremental choice offered to calling app
  / libdmtx:   Based on "incremental choice", remove unnecessary mallocs (single in stack)
  / libdmtx:   Replace dmtxScanLine() with dmtxScanPixel()
  / libdmtx:   Roll scan pattern into core library (inward breadth-first cross)
  o libdmtx:   Check ProcessEndOfSymbolTriplet() for same problem fixed in Edifact
  o libdmtx:   Rewrite encoder(s) to not need "twothirdsbits" tracking (fixes multiple bugs)
  o libdmtx:   Allow choice of edge-drop condition passed to MatrixRegionAlignEdge()
  o libdmtx:   Implement error correction (initially through libfec)
  o libdmtx:   Implement image mask to track scan progress and avoid rescanned pixels
  o libdmtx:   Implement consistent and robust error handling (errno.h + custom)
  o libdmtx:   Rename outputIdx to outputLength? (Count pad codewords instead of pointer)
  o libdmtx:   Implement --auto-fast option using algorithm from spec (lighter & faster?)
  o libdmtx:   Implement overlap detection to avoid rescanning in successfully decoded regions
  o libdmtx:   Implement structured append symbols
  o dmtxread:  JPEG support
  o dmtxread:  Add option to write image of path scanned and regions found (from mask)
  o dmtxread:  Print character values (not just codewords) from --codewords (-c) option
  x dmtxwrite: Move ASCII and codeword output to separate --preview option
  x dmtxwrite: Added -R option for setting image print resolution in dpi (PNG only)
  o dmtxwrite: Print character values (not just codewords) from --format=c (-fc) option
  o dmtxwrite: Verbose messages describing encoding process
  o testsuite: Generate metrics in reproducible format to enable historical tracking
  o testsuite: Investigate option of embedding decoded text into PNG test image comments
  o testsuite: Tests should compare scanned results to embedded PNG comments
  o testsuite: Implement exhaustive comparison between --auto-fast and --auto-best
  o testsuite: 'make test' writes metrics file
  o testsuite: 'make test' confirms performance
  x project:   Remove gltest and simpletest from default build target
  x project:   Update Subversion to be keyword friendly ($Id$)
  o project:   Figure out way to include extra files (and not .svn) without compiling
  o project:   Devise approach for recurring tasks (enabling $Id$, checking SVN commits)

version 0.4: (07-Dec-2008)
  x libdmtx:   Remove arbitrary sz scaling (100.0) since it doesn't matter anyway
  x libdmtx:   Fix 4 bottom-right modules in sizes where they are not used (thanks Matthias R.!)
  x libdmtx:   Replace callback references with preprocessor macros
  x libdmtx:   Implement remaining encodation schemes for encoding (X12, Base 256, etc...)
  x libdmtx:   Implement remaining encodation schemes for decoding (X12, Base 256, etc...)
  x libdmtx:   Implement --auto-best option for best possible encoding efficiency
  x libdmtx:   Implement multi-region symbols
  x libdmtx:   Read and write rectangle shaped barcodes
  x libdmtx:   Use GNU autotools (autoconf, automake, libtool)
  x libdmtx:   New region detection overhaul
  x libdmtx:   Fix chcon error in Makefile (right answer might be to use autoconf)
  x bindings:  Include initial version of Python bindings from pydmtx project (thanks Dan!)
  x bindings:  Add decoding functionality through Python
  x bindings:  Expose new encoding functionality through Python
  x dmtxread:  Fix dmtxread crash when same barcode is found more than 16 times
  x dmtxread:  Verbose messages describing traits of detected barcodes
  x dmtxread:  --codewords option to print codewords instead of decoded message
  x dmtxread:  --newline option to insert newline character at end of output
  x dmtxwrite: Additional output formats (PNG, ASCII, codewords)
  x testsuite: 'make test' executes regression tests for encodation
  x testsuite: Add marathon images to project (thanks John!)

version 0.3: (15-Oct-2006)
  x Use preprocessor to pull code into one big file before compiling
  x Update Makefile to handle monolithic approach; add targets for test, util, tarball
  x Rename DmtxInfo struct and variables to DmtxDecode (for consistency with DmtxEncode)
  x Merge placement logic into single implementation for both encoding and decoding
  x Deploy codebase to SourceForge CVS
  x Add revision control keywords to source files
  x Implement remaining encodation schemes in dmtxdecode.c (X12, Base 256, etc...)
  x Create separate file for callback functions (allows them to be optional)
  x Move PNG (and other format) logic and dependencies to dmtxread, dmtxwrite, etc...
  x Fix the regressions (crash bugs) introduced during v0.2 structural rework
  x Add multi-page TIFF capabilities to dmtxread
  x Move pure decode calls from dmtxScanLine into a dmtxdecode.c function
  x Sample module color from more than one pixel location
  x Rename DmtxVector3 to DmtxColor3 and merge into dmtxcolor.c
  x Fix LoadPngImage() in dmtxread.c to return image count
  x Add package/build dependencies to INSTALL file
  x Build coding style test scripts
  x Replace current calibration size estimate with new approach
  x Size step size dynamically according to pixel size
  x Improved dmtxwrite (fixed bugs, implemented -o option)
  x Increase dmtxread default scanline count (feasible because of better stability)
  x Add man page for dmtxwrite

version 0.2: (11-Jun-2006)
  x Move dmtxCapturePixel routine to library code
  x Initial restructuring of code for architectural goodness
  x Improve API for real-world use (and not just dumping results to STDOUT)
  x Add "dmtxread" command line utility
  x Add "dmtxwrite" command line utility
  x Implement error detection
  x Create "simpletest.c" for full-circle processing
  x Use libpng(3) in library to read Data Matrix images
  x Slap together some basic documentation

version 0.1: (22-Apr-2006)
  x Cycle texture images with right-click
  x Complete PlotPoint so it handles floating rows and columns
  x Implement right and left directions of FollowEdge
  x Call right and left edge following scans started from vertical step scans
  x Implement 2D vector and matrix functions
  x Trace lines with actual line object (2D ray)
  x Turn corners when encountering the end of a followed line
  x Build 2d transformation to wrap around region, assuming parallelogram
  x Display pane 4 with reverse-transformed image capture
  x Enhance dmtxCapturePixel to use "area averaging" instead of nearest neighbor
  x Figure out why squares are 3 pixels off (to start: draw white gl lines over follower paths)
  x Add callback function for PlotEventPoint(x, y, event_type)
  x Improve follower logic (weighted line fit)
  x dmtxGetPixel: do averaged interpolation followed by a tMin/tMid/tMax cutoff
  x Add in de-skew transformation
  x Refactor vector libraries to consistently list target parameter first
  x Calibrate based on calibration lines
  x Shrink-fit transformation around region


future versions:
------------------------------------------------------------------------------
  o libdmtx:   Capture high-level design in documentation (data flow, module analogies)
  o libdmtx:   Try bi-linear approximation (instead of linear) in follower edge detection
  o libdmtx:   Implement fixed point math functions for use on mobile platforms
  o libdmtx:   Port to Windows?
  o libdmtx:   Add calibration functionality to remove spherical distortion


perhaps never:
---------------------------------------------------------------------------
  o libdmtx:   Implement pre-ECC200 Data Matrix standards (big effort/low demand)


Website:
---------------------------------------------------------------------------
  o Explore using single background image instead of split
  o Add what we currently do, don't do, would like to do in the future
  o Add http://hosted-projects.com/trac/hudora/public/wiki/huBarcode to resources page


Work in progress:
---------------------------------------------------------------------------
/*
 *
 *
 */
PopulateArrayFromMatrix()
{
   int mapWidth, mapHeight;
   int xRegionCount, yRegionCount;
   int xRegionTotal, yRegionTotal;
   int weightFactor;
   int tally[24][24]; // Large enough to map largest single region

   memset(array, 0x00, sizeof(width * height * sizeof(unsigned char)));

   // Capture number of regions present in barcode
   xRegionTotal = dmtxGetSymbolAttribute(DmtxSymAttribHorizDataRegions);
   yRegionTotal = dmtxGetSymbolAttribute(DmtxSymAttribVertDataRegions);

   // Capture region dimensions (not including border modules)
   mapWidth = dmtxGetSymbolAttribute(DmtxSymAttribDataRegionCols);
   mapHeight = dmtxGetSymbolAttribute(DmtxSymAttribDataRegionRows);

   weightFactor = mapHeight + mapWidth + 2;
   assert(weightFactor > 0);

   // Tally module changes for each region in each direction
   for(yRegionCount = 0; yRegionCount < yRegionTotal; yRegionCount++) {

      // Y location of mapping region origin in symbol coordinates
      yOrigin = yRegionCount * (regionHeight + 2) + 1;

      for(xRegionCount = 0; xRegionCount < xRegionTotal; xRegionCount++) {

         // X location of mapping region origin in symbol coordinates
         xOrigin = xRegionCount * (regionWidth + 2) + 1;

         memset(&tally, 0x00, sizeof(24 * 24 * sizeof(int));
         TallyModuleJumps(tally, xOrigin, yOrigin, mapWidth, mapHeight, DmtxDirUp);
         TallyModuleJumps(tally, xOrigin, yOrigin, mapWidth, mapHeight, DmtxDirLeft);
         TallyModuleJumps(tally, xOrigin, yOrigin, mapWidth, mapHeight, DmtxDirDown);
         TallyModuleJumps(tally, xOrigin, yOrigin, mapWidth, mapHeight, DmtxDirRight);

         // Decide module status based on final tallies
         for(mapRow = 0; mapRow < mapHeight; mapRow++) {
            for(mapCol = 0; mapCol < mapWidth; mapCol++) {

               rowTmp = (yRegionCount * mapHeight) + mapRow;
               colTmp = (xRegionCount * mapWidth) + mapCol;
               idx = (rowTmp * xRegionTotal * mapWidth) + colTmp;

               if(tally[mapRow][mapCol]/(double)weightFactor > 0.6)
                  array[idx] = DMTX_MODULE_STATUS_ON_RGB;
               else if(tally[mappingRow][mappingCol]/(double)weightFactor < 0.4)
                  array[idx] = DMTX_MODULE_STATUS_OFF;
               else
                  array[idx] = DMTX_MODULE_STATUS_UNSURE;

               array[idx] |= DMTX_MODULE_ASSIGNED;
            }
         }
      }
   }
}

/*
 *
 *
 */
TallyModuleJumps(int xOrigin, int yOrigin, int mapWidth, int mapHeight, int direction)
{
   int extent;
   int symbolRow, symbolCol;
   int mappingRow, mappingCol;
   int lineStart, lineStop;
   int travelStart, travelStop;
   int *line, *travel;
   int sign;

   assert(direction == DmtxDirUp || direction == DmtxDirLeft ||
         direction == DmtxDirDown || direction == DmtxDirRight);

   travelStep = (direction == DmtxDirUp || direction == DmtxDirRight) ? 1 : -1;

   // Abstract row and column progress using pointers to allow grid
   // traversal in all 4 directions using same logic

   if(direction & DmtxDirHorizontal) {
      line = &symbolRow;
      travel = &symbolCol;
      extent = regionWidth;
      lineStart = yOrigin;
      lineStop = yOrigin + regionHeight;
      travelStart = (travelStep == 1) ? xOrigin - 1 : xOrigin + regionWidth;
      travelStop = (travelStep == 1) ? xOrigin + regionWidth : xOrigin - 1;
   }
   else {
      assert(direction & DmtxDirVertical);
      line = &symbolCol;
      travel = &symbolRow;
      extent = regionHeight;
      lineStart = xOrigin;
      lineStop = xOrigin + regionWidth;
      travelStart = (travelStep == 1) ? yOrigin - 1: yOrigin + regionHeight;
      travelStop = (travelStep == 1) ? yOrigin + regionHeight : yOrigin - 1;
   }

   weight = extent - 2;
   jumpTreshhold = fabs(); // XXX must be positive
   sameTreshhold = fabs(); // XXX must be positive

   for(*line = lineStart; *line < lineStop; (*line)++) {

      // Capture tModule for each leading border module as normal but
      // decide status based on predictable barcode border pattern

      *travel = travelStart;
      color = ReadModuleColor(decode, symbolRow, symbolCol, region->sizeIdx, region->fit2raw);
      tModule = dmtxDistanceAlongRay3(&(region->gradient.ray), &color);

      statusModule = (sign == 1 || !(*line & 0x01)) = DMTX_MODULE_ON_RGB : DMTX_MODULE_OFF;

      while((*travel += travelstep) != travelStop) {

         tPrev = tModule;
         statusPrev = statusModule;

         // For normal data-bearing modules capture color and decide
         // module status based on comparison to previous "known" module

         color = ReadModuleColor(decode, symbolRow, symbolCol, region->sizeIdx, region->fit2raw);
         tModule = dmtxDistanceAlongRay3(&(region->gradient.ray), &color);

         if(fabs(tModule - tPrev) > jumpTreshhold)
            statusModule = (statusPrev == DMTX_MODULE_OFF) ?
                  DMTX_MODULE_ON_RGB : DMTX_MODULE_ON_RGB;
         else if(fabs(tModule - tPrev) < sameThreshhold)
            statusModule = statusPrev;
         else
            statusModule = DMTX_MODULE_UNSURE;

         mapRow = symbolRow - yOrigin;
         mapCol = symbolCol - xOrigin;

         if(statusModule == DMTX_MODULE_ON_RGB)
            tally[mapRow][mapCol] += 2 * weight;
         else if(status == DMTX_MODULE_UNSURE)
            tally[mapRow][mapCol] += weight;

         weight--;
      }

      assert(weight == 0);
   }
}
