TODO Items
-----------------------------------------------------------------

version 0.1:
  x Cycle texture images with right-click
  x Complete PlotPoint so it handles floating rows and columns
  x Implement right and left directions of FollowEdge
  x Call right and left edge following scans started from vertical step scans
  x Implement 2D vector and matrix functions
  x Trace lines with actual line object (2D ray)
  x Turn corners when encountering the end of a followed line
  x Build 2d transformation to wrap around region, assuming parallelogram
  x Display pane 4 with reverse-transformed image capture
  x Enhance dmtxCapturePixel to use "area averaging" instead of nearest neighbor
  x Figure out why squares are 3 pixels off (to start: draw white gl lines over follower paths)
  x Add callback function for PlotEventPoint(x, y, event_type)
  x Improve follower logic (weighted line fit)
  x dmtxGetPixel: do averaged interpolation followed by a tMin/tMid/tMax cutoff
  x Add in de-skew transformation
  x Refactor vector libraries to consistently list target parameter first
  x Calibrate based on calibration lines
  x Shrink-fit transformation around region

version 0.2:
  x Move dmtxCapturePixel routine to library code
  x Initial restructuring of code for architectural goodness
  x Improve API for real-world use (and not just dumping results to STDOUT)
  x Add "dmtxread" command line utility
  x Add "dmtxwrite" command line utility
  x Implement error detection
  x Create "simpletest.c" for full-circle processing
  x Use libpng(3) in library to read Data Matrix images
  x Slap together some basic documentation

version 0.3:
  x Use preprocessor to pull code into one big file before compiling
  x Update Makefile to handle monolithic approach; add targets for test, util, tarball
  x Rename DmtxInfo struct and variables to DmtxDecode (for consistency with DmtxEncode)
  x Merge placement logic into single implementation for both encoding and decoding
  x Deploy codebase to SourceForge CVS
  x Add revision control keywords to source files
  x Implement remaining encodation schemes in dmtxdecode.c (X12, Base 256, etc...)
  x Create separate file for callback functions (allows them to be optional)
  x Move PNG (and other format) logic and dependencies to dmtxread, dmtxwrite, etc...
  x Fix the regressions (crash bugs) introduced during v0.2 structural rework
  x Add multi-page TIFF capabilities to dmtxread
  x Move pure decode calls from dmtxScanLine into a dmtxdecode.c function
  x Sample module color from more than one pixel location
  x Rename DmtxVector3 to DmtxColor3 and merge into dmtxcolor.c
  x Fix LoadPngImage() in dmtxread.c to return image count
  x Add package/build dependencies to INSTALL file
  x Build coding style test scripts
  x Replace current calibration size estimate with new approach
  x Size step size dynamically according to pixel size
  x Improved dmtxwrite (fixed bugs, implemented -o option)
  x Increase dmtxread default scanline count (feasible because of better stability)
  x Add man page for dmtxwrite

next version:
  o Try new approach to replace follower algorithm (beefed up ...Align() logic
  o Capture high-level design in documentation (data flow, module analogies)
  o Create dedicated module for printing encoded barcodes to image/ascii/ps/etc...
  o Investigate reported memory leak
  o Remove arbitrary sz scaling (100.0) since it doesn't matter anyway
  o Implement overlap detection to avoid rescanning in successfully decoded regions
  o Implement error correction
  o Implement consistent and robust error handling (errno.h + custom)
  o Implement remaining encodation schemes in dmtxencode.c (X12, Base 256, etc...)
  o Investigate option of embedding decoded text into PNG test image comments
  o Fix chcon error in Makefile (right answer might be to use autoconf)

future versions:
  o Add calibration functionality to remove spherical distortion
  o Use libpng(3) to write Data Matrix images
  o Use libtool
  o Tune region detection to work better with captured (non-generated) images
  o Implement structured append symbols
  o Try bi-linear approximation (instead of linear) in follower edge detection
  o Implement fixed point math functions for use on mobile platforms
  o Implement pre-ECC200 Data Matrix standards (big effort/low demand)
  o Build test suite (regression/accuracy/performance/etc...)

Notes on new follower algorithm replacement:
   Scrap the whole follower concept as we know it.  Everything is based on the
   following approach:

   1) Scanning in any of the 4 cardinal directions, find a line (any straight
      line will do)
   2) Follow the line as far as you can in both directions (this is one of the
      finder bars)
   3) Rotate and scale line boundaries to stretch from origin (0,0) to (0,1)
   4) Use MatrixRegionAlignTop() to find line that defines top edge (whether
      finder or timing) and scale top to line y=1
   5) Calculate intersection of 2 known lines

   *  Corner (0,1) is now known, but we don't know if this is the intersection
      of a finder bar and: A) the other finder bar, or B) a timing bar.  Next:

   5) Use MatrixRegionAlignBottom() to find and align bottom line
   6) Determine which line (top vs. bottom) is the other finder bar (how?)
   7) Rotate intersection of finder bars to origin (if not already there)
   8) Use MatrixRegionAlignSide() to align side
   9) Reject if any side is shorter than minModuleSize * smallestModuleCount
