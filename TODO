TODO Items
-----------------------------------------------------------------

IMMEDIATE
   x switch to incremental (one matrix) approach, which passes back buffer no matter what
      x Remove dmtxScanStartNew()
      x Remove dmtxDecodeGetMatrixCount()
      x Remove dmtxDecodeGetMatrix()
      x Add status

   x write buffer dumping function in dmtxread (takes into account b&w or rgb barcode dumps)

   / finsh writing and integrate 4-direction weighted module reads (see notes at bottom)

   o pass decision back to calling program whether to scan (requiring malloc) it
   o change dmtxFindNextRegion() to return region (not malloc'd)
   o update gltest to use the new calling structure

   / rename DmtxMatrixRegion to DmtxRegion
   o split out actual data fields
   o remove mosaic field from DmtxDecode (and replace functionality by calling dedicated named function)
   o remove DmtxRegion from decode and pass it between functions explicitly

   o write fully structured debug barcode dump from dmtxread (currently just mapping grid)
   o add data to the malloc'd image buffer (for writing log data and tracking progress)
   o improve black/white decision process
   o consider changing rounding of zero crossing math to nearest center between pixels

version 0.5:
  x libdmtx:   Remove "2" from functions named *MatrixRegion2*() (whoops)
  x libdmtx:   Fix TestForEndOfSymbolEdifact() to handle special cases correctly
  / libdmtx:   Use new Edifact decode function that doesn't assume full triplet
  / libdmtx:   Thorough test for memory leaks
  / libdmtx:   Implement multiple barcodes as incremental choice offered to calling app
  / libdmtx:   Based on "incremental choice", remove unnecessary mallocs (single in stack)
  / libdmtx:   Replace dmtxScanLine() with dmtxScanPixel()
  / libdmtx:   Roll scan pattern into core library (inward breadth-first cross)
  o libdmtx:   Check ProcessEndOfSymbolTriplet() for same problem fixed in Edifact
  o libdmtx:   Rewrite encoder(s) to not need "twothirdsbits" tracking (fixes multiple bugs)
  o libdmtx:   Allow choice of edge-drop condition passed to MatrixRegionAlignEdge()
  o libdmtx:   Implement error correction (initially through libfec)
  o libdmtx:   Implement image mask to track scan progress and avoid rescanned pixels
  o libdmtx:   Implement consistent and robust error handling (errno.h + custom)
  o libdmtx:   Rename outputIdx to outputLength? (Count pad codewords instead of pointer)
  o libdmtx:   Implement --auto-fast option using algorithm from spec (lighter & faster?)
  o libdmtx:   Implement overlap detection to avoid rescanning in successfully decoded regions
  o libdmtx:   Implement structured append symbols
  o dmtxread:  JPEG support
  o dmtxread:  Add option to write image of path scanned and regions found (from mask)
  o dmtxread:  Print character values (not just codewords) from --codewords (-c) option
  x dmtxwrite: Move ASCII and codeword output to separate --preview option
  x dmtxwrite: Added -R option for setting image print resolution in dpi (PNG only)
  o dmtxwrite: Print character values (not just codewords) from --format=c (-fc) option
  o dmtxwrite: Verbose messages describing encoding process
  o testsuite: Generate metrics in reproducible format to enable historical tracking
  o testsuite: Investigate option of embedding decoded text into PNG test image comments
  o testsuite: Tests should compare scanned results to embedded PNG comments
  o testsuite: Implement exhaustive comparison between --auto-fast and --auto-best
  o testsuite: 'make test' writes metrics file
  o testsuite: 'make test' confirms performance
  x project:   Remove gltest and simpletest from default build target
  x project:   Update Subversion to be keyword friendly ($Id$)
  o project:   Figure out way to include extra files (and not .svn) without compiling
  o project:   Devise approach for recurring tasks (enabling $Id$, checking SVN commits)

version 0.4: (07-Dec-2008)
  x libdmtx:   Remove arbitrary sz scaling (100.0) since it doesn't matter anyway
  x libdmtx:   Fix 4 bottom-right modules in sizes where they are not used (thanks Matthias R.!)
  x libdmtx:   Replace callback references with preprocessor macros
  x libdmtx:   Implement remaining encodation schemes for encoding (X12, Base 256, etc...)
  x libdmtx:   Implement remaining encodation schemes for decoding (X12, Base 256, etc...)
  x libdmtx:   Implement --auto-best option for best possible encoding efficiency
  x libdmtx:   Implement multi-region symbols
  x libdmtx:   Read and write rectangle shaped barcodes
  x libdmtx:   Use GNU autotools (autoconf, automake, libtool)
  x libdmtx:   New region detection overhaul
  x libdmtx:   Fix chcon error in Makefile (right answer might be to use autoconf)
  x bindings:  Include initial version of Python bindings from pydmtx project (thanks Dan!)
  x bindings:  Add decoding functionality through Python
  x bindings:  Expose new encoding functionality through Python
  x dmtxread:  Fix dmtxread crash when same barcode is found more than 16 times
  x dmtxread:  Verbose messages describing traits of detected barcodes
  x dmtxread:  --codewords option to print codewords instead of decoded message
  x dmtxread:  --newline option to insert newline character at end of output
  x dmtxwrite: Additional output formats (PNG, ASCII, codewords)
  x testsuite: 'make test' executes regression tests for encodation
  x testsuite: Add marathon images to project (thanks John!)

version 0.3: (15-Oct-2006)
  x Use preprocessor to pull code into one big file before compiling
  x Update Makefile to handle monolithic approach; add targets for test, util, tarball
  x Rename DmtxInfo struct and variables to DmtxDecode (for consistency with DmtxEncode)
  x Merge placement logic into single implementation for both encoding and decoding
  x Deploy codebase to SourceForge CVS
  x Add revision control keywords to source files
  x Implement remaining encodation schemes in dmtxdecode.c (X12, Base 256, etc...)
  x Create separate file for callback functions (allows them to be optional)
  x Move PNG (and other format) logic and dependencies to dmtxread, dmtxwrite, etc...
  x Fix the regressions (crash bugs) introduced during v0.2 structural rework
  x Add multi-page TIFF capabilities to dmtxread
  x Move pure decode calls from dmtxScanLine into a dmtxdecode.c function
  x Sample module color from more than one pixel location
  x Rename DmtxVector3 to DmtxColor3 and merge into dmtxcolor.c
  x Fix LoadPngImage() in dmtxread.c to return image count
  x Add package/build dependencies to INSTALL file
  x Build coding style test scripts
  x Replace current calibration size estimate with new approach
  x Size step size dynamically according to pixel size
  x Improved dmtxwrite (fixed bugs, implemented -o option)
  x Increase dmtxread default scanline count (feasible because of better stability)
  x Add man page for dmtxwrite

version 0.2: (11-Jun-2006)
  x Move dmtxCapturePixel routine to library code
  x Initial restructuring of code for architectural goodness
  x Improve API for real-world use (and not just dumping results to STDOUT)
  x Add "dmtxread" command line utility
  x Add "dmtxwrite" command line utility
  x Implement error detection
  x Create "simpletest.c" for full-circle processing
  x Use libpng(3) in library to read Data Matrix images
  x Slap together some basic documentation

version 0.1: (22-Apr-2006)
  x Cycle texture images with right-click
  x Complete PlotPoint so it handles floating rows and columns
  x Implement right and left directions of FollowEdge
  x Call right and left edge following scans started from vertical step scans
  x Implement 2D vector and matrix functions
  x Trace lines with actual line object (2D ray)
  x Turn corners when encountering the end of a followed line
  x Build 2d transformation to wrap around region, assuming parallelogram
  x Display pane 4 with reverse-transformed image capture
  x Enhance dmtxCapturePixel to use "area averaging" instead of nearest neighbor
  x Figure out why squares are 3 pixels off (to start: draw white gl lines over follower paths)
  x Add callback function for PlotEventPoint(x, y, event_type)
  x Improve follower logic (weighted line fit)
  x dmtxGetPixel: do averaged interpolation followed by a tMin/tMid/tMax cutoff
  x Add in de-skew transformation
  x Refactor vector libraries to consistently list target parameter first
  x Calibrate based on calibration lines
  x Shrink-fit transformation around region


future versions:
------------------------------------------------------------------------------
  o libdmtx:   Capture high-level design in documentation (data flow, module analogies)
  o libdmtx:   Try bi-linear approximation (instead of linear) in follower edge detection
  o libdmtx:   Implement fixed point math functions for use on mobile platforms
  o libdmtx:   Port to Windows?
  o libdmtx:   Add calibration functionality to remove spherical distortion


perhaps never:
---------------------------------------------------------------------------
  o libdmtx:   Implement pre-ECC200 Data Matrix standards (big effort/low demand)


Website:
---------------------------------------------------------------------------
  o Explore using single background image instead of split
  o Add what we currently do, don't do, would like to do in the future
  o Add http://hosted-projects.com/trac/hudora/public/wiki/huBarcode to resources page


Work in progress:
---------------------------------------------------------------------------
/*
 *
 *
 */
PopulateArrayFromMatrix()
{
   int mapWidth, mapHeight;
   int xRegionCount, yRegionCount;
   int xRegionTotal, yRegionTotal;
   double weightFactor;
   int tally[24][24]; // only needs to be as big as mapping modules of largest single region

   memset(array, 0x00, sizeof(width * height * sizeof(unsigned char)));

   // Capture region dimensions (does not include border modules)
   mapWidth = dmtxGetSymbolAttribute(DmtxSymAttribDataRegionCols);
   mapHeight = dmtxGetSymbolAttribute(DmtxSymAttribDataRegionRows);

   // Capture number of regions present in this barcode (1 if single region)
   xRegionTotal = dmtxGetSymbolAttribute(DmtxSymAttribHorizDataRegions);
   yRegionTotal = dmtxGetSymbolAttribute(DmtxSymAttribVertDataRegions);

   weightFactor = mapHeight + mapWidth + 2;
   assert(weightFactor > 0);

   // Tally module changes for each region in each direction
   for(yRegionCount = 0; yRegionCount < yRegionTotal; yRegionCount++) {

      // Y location of mapping region origin in symbol coordinates
      yOrigin = yRegionCount * (regionHeight + 2);

      for(xRegionCount = 0; xRegionCount < xRegionTotal; xRegionCount++) {

         // X location of mapping region origin in symbol coordinates
         xOrigin = xRegionCount * (regionWidth + 2);

         memset(&tally, 0x00, sizeof(24 * 24 * sizeof(int));
         TallyModuleJumps(tally, xOrigin, yOrigin, mapWidth, mapHeight, DmtxDirUp);
         TallyModuleJumps(tally, xOrigin, yOrigin, mapWidth, mapHeight, DmtxDirLeft);
         TallyModuleJumps(tally, xOrigin, yOrigin, mapWidth, mapHeight, DmtxDirDown);
         TallyModuleJumps(tally, xOrigin, yOrigin, mapWidth, mapHeight, DmtxDirRight);

         // Decide module status based on final tallies
         for(mapRow = 0; mapRow < mapHeight * yRegionTotal; mapRow++) {
            for(mapCol = 0; mapCol < mapWidth * xRegionTotal; mapCol++) {

               idx = XYZ; // XXX

               if(tally[mapRow][mapCol]/weightFactor > 0.55)
                  array[idx] = DMTX_MODULE_STATUS_ON_RGB;
               else if(tally[mappingRow][mappingCol]/weightFactor < 0.45)
                  array[idx] = DMTX_MODULE_STATUS_OFF;
               else
                  array[idx] = DMTX_MODULE_STATUS_UNSURE;

               array[idx] |= DMTX_MODULE_ASSIGNED;
            }
         }
      }
   }
}

/*
 *
 *
 */
TallyModuleJumps(int xOrigin, int yOrigin, int mapWidth, int mapHeight, int direction)
{
   int extent;
   int symbolRow, symbolCol;
   int mappingRow, mappingCol;
   int lineStart, lineStop;
   int travelStart, travelStop;
   int *line, *travel;
   int sign;

   assert(direction == DmtxDirUp || direction == DmtxDirLeft ||
         direction == DmtxDirDown || direction == DmtxDirRight);

   travelStep = (direction == DmtxDirUp || direction == DmtxDirRight) ? 1 : -1;

   if(direction & DmtxDirHorizontal) {
      line = &symbolRow;
      travel = &symbolCol;
      extent = regionWidth;
      lineStart = yRegionOrigin;
      lineStop = yRegionOrigin + regionHeight;
      travelStart = (travelStep == 1) ? xRegionOrigin - 1 : xRegionOrigin + regionWidth;
      travelStop = (travelStep == 1) ? xRegionOrigin + regionWidth : xRegionOrigin - 1;
   }
   else {
      assert(direction & DmtxDirVertical);
      line = &symbolCol;
      travel = &symbolRow;
      extent = regionHeight;
      lineStart = xRegionOrigin;
      lineStop = xRegionOrigin + regionWidth;
      travelStart = (travelStep == 1) ? yRegionOrigin - 1: yRegionOrigin + regionHeight;
      travelStop = (travelStep == 1) ? yRegionOrigin + regionHeight : yRegionOrigin - 1;
   }

   for(*line = lineStart; *line < lineStop ; (*line)++) {

      weight = extent - 2;

      for(*travel = travelStart; *travel != travelStop; *travel += travelStep) {

         color = ReadModuleColor(decode, symbolRow, symbolCol, region->sizeIdx, region->fit2raw);
         tModule = dmtxDistanceAlongRay3(&(region->gradient.ray), &color);

         // set initial module status based on direction and line number
         if(*travel == travelStart) {
            statusModule = (sign == 1 || ((symbolRow + symbolCol) & 0x01)) = DMTX_MODULE_ON_RGB : 0;
            continue;
         }

         tPrev = t;
         statusPrev = status;

         status = (compare t toPrev)

         mapRow = f(symbolRow);
         mapCol = f(symbolCol);

         if(status == on)
            tally[mapRow][mapCol] += (weight * 2);
         else if(status == unsure)
            tally[mapRow][mapCol] += (weight);

         *travel += travelStep;

         weight--;
      }

      assert(weight == 0);
   }
}

/* example:

14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14
14 13 12 11 10 09 08 07 06 05 04 03 02 01  01 02 03 04 05 06 07 08 09 10 11 12 13 14

14 14 14 14 14 14 14 14 14 14 14 14 14 14  01 01 01 01 01 01 01 01 01 01 01 01 01 01
13 13 13 13 13 13 13 13 13 13 13 13 13 13  02 02 02 02 02 02 02 02 02 02 02 02 02 02
12 12 12 12 12 12 12 12 12 12 12 12 12 12  03 03 03 03 03 03 03 03 03 03 03 03 03 03
11 11 11 11 11 11 11 11 11 11 11 11 11 11  04 04 04 04 04 04 04 04 04 04 04 04 04 04
10 10 10 10 10 10 10 10 10 10 10 10 10 10  05 05 05 05 05 05 05 05 05 05 05 05 05 05
09 09 09 09 09 09 09 09 09 09 09 09 09 09  06 06 06 06 06 06 06 06 06 06 06 06 06 06
08 08 08 08 08 08 08 08 08 08 08 08 08 08  07 07 07 07 07 07 07 07 07 07 07 07 07 07
07 07 07 07 07 07 07 07 07 07 07 07 07 07  08 08 08 08 08 08 08 08 08 08 08 08 08 08
06 06 06 06 06 06 06 06 06 06 06 06 06 06  09 09 09 09 09 09 09 09 09 09 09 09 09 09
05 05 05 05 05 05 05 05 05 05 05 05 05 05  10 10 10 10 10 10 10 10 10 10 10 10 10 10
04 04 04 04 04 04 04 04 04 04 04 04 04 04  11 11 11 11 11 11 11 11 11 11 11 11 11 11
03 03 03 03 03 03 03 03 03 03 03 03 03 03  12 12 12 12 12 12 12 12 12 12 12 12 12 12
02 02 02 02 02 02 02 02 02 02 02 02 02 02  13 13 13 13 13 13 13 13 13 13 13 13 13 13
01 01 01 01 01 01 01 01 01 01 01 01 01 01  14 14 14 14 14 14 14 14 14 14 14 14 14 14

The four grids above add together to       30 30 30 30 30 30 30 30 30 30 30 30 30 30
create a grid of like values ------>       30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30
                                           30 30 30 30 30 30 30 30 30 30 30 30 30 30

02 00 00 00 01 00 02 00 00 00 00 00 00 00  <-- Take this grid, where:
00 00 00 00 02 00 00 02 00 00 02 00 02 00
00 00 00 00 02 00 02 00 00 00 02 00 00 02      0 = OFF
00 02 01 00 00 00 00 00 00 02 00 00 01 00      1 = UNSURE
00 02 00 02 00 00 00 02 00 00 02 00 00 00      2 = ON
02 00 00 00 00 01 00 02 00 00 00 00 00 00
02 02 02 00 00 02 00 00 00 00 00 00 02 00      When multipied by four weight matrices
00 00 00 02 00 00 00 02 00 02 00 02 00 00      above (based on directional scan) then
02 02 00 02 00 00 00 02 02 00 02 02 00 02      you get the four results below ...
02 00 00 00 00 00 02 00 00 00 00 02 02 02
00 00 01 02 02 02 00 02 00 00 00 00 02 01
00 00 00 00 00 00 00 00 00 00 00 00 02 00
00 00 02 00 00 00 00 00 00 00 02 00 00 00
00 00 00 02 00 02 00 02 00 01 00 02 00 00

28 00 00 00 10 00 16 00 00 00 00 00 00 00  02 00 00 00 05 00 14 00 00 00 00 00 00 00
00 00 00 00 20 00 00 14 00 00 08 00 04 00  00 00 00 00 10 00 00 16 00 00 22 00 26 00
00 00 00 00 20 00 16 00 00 00 08 00 00 02  00 00 00 00 10 00 14 00 00 00 22 00 00 28
00 26 12 00 00 00 00 00 00 10 00 00 02 00  00 04 03 00 00 00 00 00 00 20 00 00 13 00
00 26 00 22 00 00 00 14 00 00 08 00 00 00  00 04 00 08 00 00 00 16 00 00 22 00 00 00
28 00 00 00 00 09 00 14 00 00 00 00 00 00  02 00 00 00 00 06 00 16 00 00 00 00 00 00
28 26 24 00 00 18 00 00 00 00 00 00 04 00  02 04 06 00 00 12 00 00 00 00 00 00 26 00
00 00 00 22 00 00 00 14 00 10 00 06 00 00  00 00 00 08 00 00 00 16 00 20 00 24 00 00
28 26 00 22 00 00 00 14 12 00 08 06 00 02  02 04 00 08 00 00 00 16 18 00 22 24 00 28
28 00 00 00 00 00 16 00 00 00 00 06 04 02  02 00 00 00 00 00 14 00 00 00 00 24 26 28
00 00 12 22 20 18 00 14 00 00 00 00 04 01  00 00 03 08 10 12 00 16 00 00 00 00 26 14
00 00 00 00 00 00 00 00 00 00 00 00 04 00  00 00 00 00 00 00 00 00 00 00 00 00 26 00
00 00 24 00 00 00 00 00 00 00 08 00 00 00  00 00 06 00 00 00 00 00 00 00 22 00 00 00
00 00 00 22 00 18 00 14 00 05 00 06 00 00  00 00 00 08 00 12 00 16 00 10 00 24 00 00

28 00 00 00 14 00 28 00 00 00 00 00 00 00  02 00 00 00 01 00 02 00 00 00 00 00 00 00
00 00 00 00 26 00 00 26 00 00 26 00 26 00  00 00 00 00 04 00 00 04 00 00 04 00 04 00
00 00 00 00 24 00 24 00 00 00 24 00 00 24  00 00 00 00 06 00 06 00 00 00 06 00 00 06
00 22 11 00 00 00 00 00 00 22 00 00 11 00  00 08 04 00 00 00 00 00 00 08 00 00 04 00
00 20 00 20 00 00 00 20 00 00 20 00 00 00  00 10 00 10 00 00 00 10 00 00 10 00 00 00
18 00 00 00 00 09 00 18 00 00 00 00 00 00  12 00 00 00 00 06 00 12 00 00 00 00 00 00
16 16 16 00 00 16 00 00 00 00 00 00 16 00  14 14 14 00 00 14 00 00 00 00 00 00 14 00
00 00 00 14 00 00 00 14 00 14 00 14 00 00  00 00 00 16 00 00 00 16 00 16 00 16 00 00
12 12 00 12 00 00 00 12 12 00 12 12 00 12  18 18 00 18 00 00 00 18 18 00 18 18 00 18
10 00 00 00 00 00 10 00 00 00 00 10 10 10  20 00 00 00 00 00 20 00 00 00 00 20 20 20
00 00 04 08 08 08 00 08 00 00 00 00 08 04  00 00 11 22 22 22 00 22 00 00 00 00 22 11
00 00 00 00 00 00 00 00 00 00 00 00 06 00  00 00 00 00 00 00 00 00 00 00 00 00 24 00
00 00 04 00 00 00 00 00 00 00 04 00 00 00  00 00 26 00 00 00 00 00 00 00 26 00 00 00
00 00 00 02 00 02 00 02 00 01 00 02 00 00  00 00 00 28 00 28 00 28 00 14 00 28 00 00

... resulting in this final weighted       02 00 00 00 01 00 02 00 00 00 00 00 00 00
    results matrix (shown after            00 00 00 00 02 00 00 02 00 00 02 00 02 00
    dividing by 30) --------------->       00 00 00 00 02 00 02 00 00 00 02 00 00 02
                                           00 02 01 00 00 00 00 00 00 02 00 00 01 00
                                           00 02 00 02 00 00 00 02 00 00 02 00 00 00
                                           02 00 00 00 00 01 00 02 00 00 00 00 00 00
                                           02 02 02 00 00 02 00 00 00 00 00 00 02 00
                                           00 00 00 02 00 00 00 02 00 02 00 02 00 00
                                           02 02 00 02 00 00 00 02 02 00 02 02 00 02
                                           02 00 00 00 00 00 02 00 00 00 00 02 02 02
                                           00 00 01 02 02 02 00 02 00 00 00 00 02 01
                                           00 00 00 00 00 00 00 00 00 00 00 00 02 00
                                           00 00 02 00 00 00 00 00 00 00 02 00 00 00
                                           00 00 00 02 00 02 00 02 00 01 00 02 00 00
*/
